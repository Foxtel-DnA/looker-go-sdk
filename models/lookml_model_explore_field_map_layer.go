// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LookmlModelExploreFieldMapLayer lookml model explore field map layer
//
// swagger:model LookmlModelExploreFieldMapLayer
type LookmlModelExploreFieldMapLayer struct {

	// Specifies the URL to a JSON file that defines the geographic extents of each region available in the map layer. This data is used to automatically center the map on the available data for visualization purposes. The JSON file must be a JSON object where the keys are the mapping value of the feature (as specified by property_key) and the values are arrays of four numbers representing the west longitude, south latitude, east longitude, and north latitude extents of the region. The object must include a key for every possible value of property_key.
	// Read Only: true
	ExtentsJSONURL string `json:"extents_json_url,omitempty"`

	// Specifies the name of the TopoJSON object that the map layer references. If not specified, use the first object..
	// Read Only: true
	FeatureKey string `json:"feature_key,omitempty"`

	// Specifies the data format of the region information. Valid values are: "topojson", "vector_tile_region".
	// Read Only: true
	Format string `json:"format,omitempty"`

	// The minimum zoom level that the map layer may be displayed at, for visualizations that support zooming.
	// Read Only: true
	MaxZoomLevel int64 `json:"max_zoom_level,omitempty"`

	// The maximum zoom level that the map layer may be displayed at, for visualizations that support zooming.
	// Read Only: true
	MinZoomLevel int64 `json:"min_zoom_level,omitempty"`

	// Name of the map layer, as defined in LookML.
	// Read Only: true
	Name string `json:"name,omitempty"`

	// The preferred geographic projection of the map layer when displayed in a visualization that supports multiple geographic projections.
	// Read Only: true
	Projection string `json:"projection,omitempty"`

	// Selects which property from the TopoJSON data to plot against. TopoJSON supports arbitrary metadata for each region. When null, the first matching property should be used.
	// Read Only: true
	PropertyKey string `json:"property_key,omitempty"`

	// Which property from the TopoJSON data to use to label the region. When null, property_key should be used.
	// Read Only: true
	PropertyLabelKey string `json:"property_label_key,omitempty"`

	// URL to the map layer resource.
	// Read Only: true
	URL string `json:"url,omitempty"`
}

// Validate validates this lookml model explore field map layer
func (m *LookmlModelExploreFieldMapLayer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this lookml model explore field map layer based on the context it is used
func (m *LookmlModelExploreFieldMapLayer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExtentsJSONURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFeatureKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFormat(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMaxZoomLevel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMinZoomLevel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProjection(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePropertyKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePropertyLabelKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LookmlModelExploreFieldMapLayer) contextValidateExtentsJSONURL(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "extents_json_url", "body", string(m.ExtentsJSONURL)); err != nil {
		return err
	}

	return nil
}

func (m *LookmlModelExploreFieldMapLayer) contextValidateFeatureKey(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "feature_key", "body", string(m.FeatureKey)); err != nil {
		return err
	}

	return nil
}

func (m *LookmlModelExploreFieldMapLayer) contextValidateFormat(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "format", "body", string(m.Format)); err != nil {
		return err
	}

	return nil
}

func (m *LookmlModelExploreFieldMapLayer) contextValidateMaxZoomLevel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "max_zoom_level", "body", int64(m.MaxZoomLevel)); err != nil {
		return err
	}

	return nil
}

func (m *LookmlModelExploreFieldMapLayer) contextValidateMinZoomLevel(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "min_zoom_level", "body", int64(m.MinZoomLevel)); err != nil {
		return err
	}

	return nil
}

func (m *LookmlModelExploreFieldMapLayer) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *LookmlModelExploreFieldMapLayer) contextValidateProjection(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "projection", "body", string(m.Projection)); err != nil {
		return err
	}

	return nil
}

func (m *LookmlModelExploreFieldMapLayer) contextValidatePropertyKey(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "property_key", "body", string(m.PropertyKey)); err != nil {
		return err
	}

	return nil
}

func (m *LookmlModelExploreFieldMapLayer) contextValidatePropertyLabelKey(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "property_label_key", "body", string(m.PropertyLabelKey)); err != nil {
		return err
	}

	return nil
}

func (m *LookmlModelExploreFieldMapLayer) contextValidateURL(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "url", "body", string(m.URL)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LookmlModelExploreFieldMapLayer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LookmlModelExploreFieldMapLayer) UnmarshalBinary(b []byte) error {
	var res LookmlModelExploreFieldMapLayer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
