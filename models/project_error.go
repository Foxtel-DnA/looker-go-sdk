// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProjectError project error
//
// swagger:model ProjectError
type ProjectError struct {

	// A stable token that uniquely identifies this class of error, ignoring parameter values. Error message text may vary due to parameters or localization, but error codes do not. For example, a "File not found" error will have the same error code regardless of the filename in question or the user's display language
	// Read Only: true
	Code string `json:"code,omitempty"`

	// The explore associated with this error
	// Read Only: true
	Explore string `json:"explore,omitempty"`

	// The field associated with this error
	// Read Only: true
	FieldName string `json:"field_name,omitempty"`

	// Name of the file containing this error
	// Read Only: true
	FilePath string `json:"file_path,omitempty"`

	// A link to Looker documentation about this error
	// Read Only: true
	HelpURL string `json:"help_url,omitempty"`

	// Error classification: syntax, deprecation, model_configuration, etc
	// Read Only: true
	Kind string `json:"kind,omitempty"`

	// Line number in the file of this error
	// Read Only: true
	LineNumber int64 `json:"line_number,omitempty"`

	// Error message which may contain information such as dashboard or model names that may be considered sensitive in some use cases. Avoid storing or sending this message outside of Looker
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The model associated with this error
	// Read Only: true
	ModelID string `json:"model_id,omitempty"`

	// Error parameters
	// Read Only: true
	Params map[string]string `json:"params,omitempty"`

	// A version of the error message that does not contain potentially sensitive information. Suitable for situations in which messages are stored or sent to consumers outside of Looker, such as external logs. Sanitized messages will display "(?)" where sensitive information would appear in the corresponding non-sanitized message
	// Read Only: true
	SanitizedMessage string `json:"sanitized_message,omitempty"`

	// Severity: fatal, error, warning, info, success
	// Read Only: true
	Severity string `json:"severity,omitempty"`
}

// Validate validates this project error
func (m *ProjectError) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this project error based on the context it is used
func (m *ProjectError) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExplore(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFieldName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilePath(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHelpURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKind(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLineNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModelID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSanitizedMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSeverity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProjectError) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "code", "body", string(m.Code)); err != nil {
		return err
	}

	return nil
}

func (m *ProjectError) contextValidateExplore(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "explore", "body", string(m.Explore)); err != nil {
		return err
	}

	return nil
}

func (m *ProjectError) contextValidateFieldName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "field_name", "body", string(m.FieldName)); err != nil {
		return err
	}

	return nil
}

func (m *ProjectError) contextValidateFilePath(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "file_path", "body", string(m.FilePath)); err != nil {
		return err
	}

	return nil
}

func (m *ProjectError) contextValidateHelpURL(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "help_url", "body", string(m.HelpURL)); err != nil {
		return err
	}

	return nil
}

func (m *ProjectError) contextValidateKind(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "kind", "body", string(m.Kind)); err != nil {
		return err
	}

	return nil
}

func (m *ProjectError) contextValidateLineNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "line_number", "body", int64(m.LineNumber)); err != nil {
		return err
	}

	return nil
}

func (m *ProjectError) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(m.Message)); err != nil {
		return err
	}

	return nil
}

func (m *ProjectError) contextValidateModelID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "model_id", "body", string(m.ModelID)); err != nil {
		return err
	}

	return nil
}

func (m *ProjectError) contextValidateParams(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ProjectError) contextValidateSanitizedMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sanitized_message", "body", string(m.SanitizedMessage)); err != nil {
		return err
	}

	return nil
}

func (m *ProjectError) contextValidateSeverity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "severity", "body", string(m.Severity)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProjectError) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProjectError) UnmarshalBinary(b []byte) error {
	var res ProjectError
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
