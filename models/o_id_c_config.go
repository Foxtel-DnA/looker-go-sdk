// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OIDCConfig o ID c config
//
// swagger:model OIDCConfig
type OIDCConfig struct {

	// Allows roles to be directly assigned to OIDC auth'd users.
	AllowDirectRoles bool `json:"allow_direct_roles,omitempty"`

	// Allow OIDC auth'd users to be members of non-reflected Looker groups. If 'false', user will be removed from non-reflected groups on login.
	AllowNormalGroupMembership bool `json:"allow_normal_group_membership,omitempty"`

	// OIDC auth'd users will inherit roles from non-reflected Looker groups.
	AllowRolesFromNormalGroups bool `json:"allow_roles_from_normal_groups,omitempty"`

	// Allow alternate email-based login via '/login/email' for admins and for specified users with the 'login_special_email' permission. This option is useful as a fallback during ldap setup, if ldap config problems occur later, or if you need to support some users who are not in your ldap directory. Looker email/password logins are always disabled for regular users when ldap is enabled.
	AlternateEmailLoginAllowed bool `json:"alternate_email_login_allowed,omitempty"`

	// OpenID Provider Audience
	Audience string `json:"audience,omitempty"`

	// Users will not be allowed to login at all unless a role for them is found in OIDC if set to true
	AuthRequiresRole bool `json:"auth_requires_role,omitempty"`

	// OpenID Provider Authorization Url
	// Format: uri
	AuthorizationEndpoint strfmt.URI `json:"authorization_endpoint,omitempty"`

	// Operations the current user is able to perform on this object
	// Read Only: true
	Can map[string]bool `json:"can,omitempty"`

	// (Write-Only) Array of ids of groups that will be applied to new users the first time they login via OIDC
	DefaultNewUserGroupIds []int64 `json:"default_new_user_group_ids"`

	// (Read-only) Groups that will be applied to new users the first time they login via OIDC
	// Read Only: true
	DefaultNewUserGroups []*Group `json:"default_new_user_groups"`

	// (Write-Only) Array of ids of roles that will be applied to new users the first time they login via OIDC
	DefaultNewUserRoleIds []int64 `json:"default_new_user_role_ids"`

	// (Read-only) Roles that will be applied to new users the first time they login via OIDC
	// Read Only: true
	DefaultNewUserRoles []*Role `json:"default_new_user_roles"`

	// Enable/Disable OIDC authentication for the server
	Enabled bool `json:"enabled,omitempty"`

	// (Read-only) Array of mappings between OIDC Groups and Looker Roles
	// Read Only: true
	Groups []*OIDCGroupRead `json:"groups"`

	// Name of user record attributes used to indicate groups. Used when 'groups_finder_type' is set to 'grouped_attribute_values'
	GroupsAttribute string `json:"groups_attribute,omitempty"`

	// (Read/Write) Array of mappings between OIDC Groups and arrays of Looker Role ids
	GroupsWithRoleIds []*OIDCGroupWrite `json:"groups_with_role_ids"`

	// Relying Party Identifier (provided by OpenID Provider)
	Identifier string `json:"identifier,omitempty"`

	// OpenID Provider Issuer
	Issuer string `json:"issuer,omitempty"`

	// When this config was last modified
	// Read Only: true
	// Format: date-time
	ModifiedAt strfmt.DateTime `json:"modified_at,omitempty"`

	// User id of user who last modified this config
	// Read Only: true
	ModifiedBy int64 `json:"modified_by,omitempty"`

	// Merge first-time oidc login to existing user account by email addresses. When a user logs in for the first time via oidc this option will connect this user into their existing account by finding the account with a matching email address by testing the given types of credentials for existing users. Otherwise a new user account will be created for the user. This list (if provided) must be a comma separated list of string like 'email,ldap,google'
	NewUserMigrationTypes string `json:"new_user_migration_types,omitempty"`

	// Array of scopes to request.
	Scopes []string `json:"scopes"`

	// (Write-Only) Relying Party Secret (provided by OpenID Provider)
	Secret string `json:"secret,omitempty"`

	// Set user roles in Looker based on groups from OIDC
	SetRolesFromGroups bool `json:"set_roles_from_groups,omitempty"`

	// Slug to identify configurations that are created in order to run a OIDC config test
	// Read Only: true
	TestSlug string `json:"test_slug,omitempty"`

	// OpenID Provider Token Url
	TokenEndpoint string `json:"token_endpoint,omitempty"`

	// Link to get this item
	// Read Only: true
	// Format: uri
	URL strfmt.URI `json:"url,omitempty"`

	// Name of user record attributes used to indicate email address field
	UserAttributeMapEmail string `json:"user_attribute_map_email,omitempty"`

	// Name of user record attributes used to indicate first name
	UserAttributeMapFirstName string `json:"user_attribute_map_first_name,omitempty"`

	// Name of user record attributes used to indicate last name
	UserAttributeMapLastName string `json:"user_attribute_map_last_name,omitempty"`

	// (Read-only) Array of mappings between OIDC User Attributes and Looker User Attributes
	// Read Only: true
	UserAttributes []*OIDCUserAttributeRead `json:"user_attributes"`

	// (Read/Write) Array of mappings between OIDC User Attributes and arrays of Looker User Attribute ids
	UserAttributesWithIds []*OIDCUserAttributeWrite `json:"user_attributes_with_ids"`

	// OpenID Provider User Information Url
	// Format: uri
	UserinfoEndpoint strfmt.URI `json:"userinfo_endpoint,omitempty"`
}

// Validate validates this o ID c config
func (m *OIDCConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthorizationEndpoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultNewUserGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultNewUserRoles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupsWithRoleIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAttributesWithIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserinfoEndpoint(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OIDCConfig) validateAuthorizationEndpoint(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthorizationEndpoint) { // not required
		return nil
	}

	if err := validate.FormatOf("authorization_endpoint", "body", "uri", m.AuthorizationEndpoint.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OIDCConfig) validateDefaultNewUserGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultNewUserGroups) { // not required
		return nil
	}

	for i := 0; i < len(m.DefaultNewUserGroups); i++ {
		if swag.IsZero(m.DefaultNewUserGroups[i]) { // not required
			continue
		}

		if m.DefaultNewUserGroups[i] != nil {
			if err := m.DefaultNewUserGroups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("default_new_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) validateDefaultNewUserRoles(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultNewUserRoles) { // not required
		return nil
	}

	for i := 0; i < len(m.DefaultNewUserRoles); i++ {
		if swag.IsZero(m.DefaultNewUserRoles[i]) { // not required
			continue
		}

		if m.DefaultNewUserRoles[i] != nil {
			if err := m.DefaultNewUserRoles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("default_new_user_roles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) validateGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.Groups) { // not required
		return nil
	}

	for i := 0; i < len(m.Groups); i++ {
		if swag.IsZero(m.Groups[i]) { // not required
			continue
		}

		if m.Groups[i] != nil {
			if err := m.Groups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) validateGroupsWithRoleIds(formats strfmt.Registry) error {
	if swag.IsZero(m.GroupsWithRoleIds) { // not required
		return nil
	}

	for i := 0; i < len(m.GroupsWithRoleIds); i++ {
		if swag.IsZero(m.GroupsWithRoleIds[i]) { // not required
			continue
		}

		if m.GroupsWithRoleIds[i] != nil {
			if err := m.GroupsWithRoleIds[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("groups_with_role_ids" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) validateModifiedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("modified_at", "body", "date-time", m.ModifiedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OIDCConfig) validateURL(formats strfmt.Registry) error {
	if swag.IsZero(m.URL) { // not required
		return nil
	}

	if err := validate.FormatOf("url", "body", "uri", m.URL.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OIDCConfig) validateUserAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.UserAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.UserAttributes); i++ {
		if swag.IsZero(m.UserAttributes[i]) { // not required
			continue
		}

		if m.UserAttributes[i] != nil {
			if err := m.UserAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("user_attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) validateUserAttributesWithIds(formats strfmt.Registry) error {
	if swag.IsZero(m.UserAttributesWithIds) { // not required
		return nil
	}

	for i := 0; i < len(m.UserAttributesWithIds); i++ {
		if swag.IsZero(m.UserAttributesWithIds[i]) { // not required
			continue
		}

		if m.UserAttributesWithIds[i] != nil {
			if err := m.UserAttributesWithIds[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("user_attributes_with_ids" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) validateUserinfoEndpoint(formats strfmt.Registry) error {
	if swag.IsZero(m.UserinfoEndpoint) { // not required
		return nil
	}

	if err := validate.FormatOf("userinfo_endpoint", "body", "uri", m.UserinfoEndpoint.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this o ID c config based on the context it is used
func (m *OIDCConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefaultNewUserGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefaultNewUserRoles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGroupsWithRoleIds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedAt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModifiedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTestSlug(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserAttributesWithIds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OIDCConfig) contextValidateCan(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *OIDCConfig) contextValidateDefaultNewUserGroups(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "default_new_user_groups", "body", []*Group(m.DefaultNewUserGroups)); err != nil {
		return err
	}

	for i := 0; i < len(m.DefaultNewUserGroups); i++ {

		if m.DefaultNewUserGroups[i] != nil {
			if err := m.DefaultNewUserGroups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("default_new_user_groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) contextValidateDefaultNewUserRoles(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "default_new_user_roles", "body", []*Role(m.DefaultNewUserRoles)); err != nil {
		return err
	}

	for i := 0; i < len(m.DefaultNewUserRoles); i++ {

		if m.DefaultNewUserRoles[i] != nil {
			if err := m.DefaultNewUserRoles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("default_new_user_roles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) contextValidateGroups(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "groups", "body", []*OIDCGroupRead(m.Groups)); err != nil {
		return err
	}

	for i := 0; i < len(m.Groups); i++ {

		if m.Groups[i] != nil {
			if err := m.Groups[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) contextValidateGroupsWithRoleIds(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GroupsWithRoleIds); i++ {

		if m.GroupsWithRoleIds[i] != nil {
			if err := m.GroupsWithRoleIds[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("groups_with_role_ids" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) contextValidateModifiedAt(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modified_at", "body", strfmt.DateTime(m.ModifiedAt)); err != nil {
		return err
	}

	return nil
}

func (m *OIDCConfig) contextValidateModifiedBy(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "modified_by", "body", int64(m.ModifiedBy)); err != nil {
		return err
	}

	return nil
}

func (m *OIDCConfig) contextValidateTestSlug(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "test_slug", "body", string(m.TestSlug)); err != nil {
		return err
	}

	return nil
}

func (m *OIDCConfig) contextValidateURL(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "url", "body", strfmt.URI(m.URL)); err != nil {
		return err
	}

	return nil
}

func (m *OIDCConfig) contextValidateUserAttributes(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "user_attributes", "body", []*OIDCUserAttributeRead(m.UserAttributes)); err != nil {
		return err
	}

	for i := 0; i < len(m.UserAttributes); i++ {

		if m.UserAttributes[i] != nil {
			if err := m.UserAttributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("user_attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OIDCConfig) contextValidateUserAttributesWithIds(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UserAttributesWithIds); i++ {

		if m.UserAttributesWithIds[i] != nil {
			if err := m.UserAttributesWithIds[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("user_attributes_with_ids" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *OIDCConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OIDCConfig) UnmarshalBinary(b []byte) error {
	var res OIDCConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
